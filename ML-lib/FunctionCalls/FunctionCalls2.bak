#lang racket
;THIS LANGUAGE IMPLEMENTS FUNCTION CALLS USING GOTO'S.
;IN PARTICULAR, ONCE A FUNCTION RETURNS, IT WILL RETURN
;FOR ITS CORRESPONDING BODY INSTEAD OF GOING BACK TO WHERE YOU
;WOULD NORMALLY THINK IT DOES. I.E (+ 1 (f x)) WILL JUST RETURN
;(f x) (or if f calls another function in its body, it will return
;that function's result instead)

(require (prefix-in Cond- "../Conditionals/Conditionals3.rkt")
         "../ML-Helpers.rkt"
         "FunctionCallsHelpers.rkt"
         (for-syntax syntax/parse))
(provide
 (rename-out [my-module #%module-begin])
 (except-out (unprefix-out Cond- "../Conditionals/Conditionals3.rkt")
             Cond-#%module-begin)
 func)

;We make a tag to tell our functions where to return to.
(define prompt-tag (make-continuation-prompt-tag))

;When they return, they throw away the current continuation and jump
;to our prompt tag.
(define-syntax-rule (func name (args ...) body ... last-body)
  (define (name args ...)
      (check-decrement-fuel)
      (let ([result ((lambda () body ... last-body))])
        (abort-current-continuation prompt-tag result))))



;Calls each body (save for function definitions)
;with a call/cc.
(define-syntax (my-module stx*)
  (syntax-case stx* ()
    [(_ body ...)
     #'(Cond-#%module-begin
        (fill-tank)
        (expand body) ...)]))

;As let is splicing, the expansion needs to go into it.
(define-syntax (expand stx)
  (syntax-case stx ()
    [(_ body) (syntax-parse #'body #:literals(func)
                [(func _ ...) #'body]
                [x #'(call-with-continuation-prompt
                      (lambda ()  (let ([res (let () (values) x)]) res))
                      prompt-tag
                      (lambda (v) v))])]))
