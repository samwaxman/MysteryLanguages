#lang racket
(require (prefix-in Cond- "../Conditionals/Conditionals3.rkt")
         (for-syntax syntax/parse)
         racket/splicing
         "../ML-Helpers.rkt"
         racket/stxparam)
(provide
 (except-out (unprefix-out Cond- "../Conditionals/Conditionals3.rkt")
             Cond-#%top Cond-#%module-begin Cond-let Cond-if)
 (rename-out [syn-let let]
             [my-module-begin #%module-begin]
             [my-top #%top]
             [my-if if])
 func)





;;Our environment!
(define env '())

;;Must use a function defined in this file
;;To set the environment. set! is not allowed
;;To appear in the syntax of other files when
;;It's trying to set a module provided identifier
(define (set-env new-env)
  (set! env new-env))

;; Delays the lookup until runtime.
(define-syntax-rule (my-top . var)
  (lookup 'var))

;;Looks up var (must be a literal, not the var itself) in the environment
(define (lookup var)
  (define (lookup-helper var flat-env)
    (cond
      [(null? flat-env) (error "Unbound identifier.")]
      [(cons? flat-env) (if (eq? (vector-ref (car flat-env) 0)
                                 var)
                            (vector-ref (car flat-env) 1)
                            (lookup-helper var (cdr flat-env)))]))
  (lookup-helper var (flatten env)))

;;Pushes a binding onto the environment
(define-syntax-rule (push id binding)
  (set-env (cons (cons (vector 'id binding) (car env)) (cdr env))))

;;Begins a new scope
(define (begin-scope)
  (set-env (cons null env)))

;;Pops the things we defined in the current scope
;;from the environment
(define (exit-scope)
  (set-env (cdr env)))

;; Adds the bindings to the environment, evaluates the body,
;; and then pops off the bindings
(define-syntax-rule (with-bindings ([var binding] ...) body ...)
  (begin
    (begin-scope)
    (push var binding) ...
    ;;Change the immediate lambdas to let () in these cases
    (let ([result (let () body ...)])
      (exit-scope)
      result)))
  
(define-syntax-rule (my-let ([id binding]) body ... last-body)
  (begin (begin-scope) (push id binding) body ... last-body (exit-scope)))
(define-syntax-rule (block-let ([id binding]) body ... last-body)
  (begin (begin-scope) (push id binding) (let ([result (begin body ... last-body)])
                                           (exit-scope) result)))

(define-syntax-parameter syn-let (syntax-rules () [(_ stx ...) (my-let stx ...)]))



(define-syntax-rule (my-module-begin body ...)
  (Cond-#%module-begin (set-env '()) (begin-scope) body ... (exit-scope)))



;;Pushes func binding onto the environment,
;;and pushes the function-argument bindings onto the environment
;;whenever the function is called.
(define-syntax (func stx)
  (syntax-case stx ()
    [(_ name (args ...) body ... last-body)
     (with-syntax ([(user-args ...) (generate-temporaries #'(args ...))])
       #'(syntax-parameterize ([syn-let (...(syntax-rules () [(_ stx ...) (block-let stx ...)]))])
           (push name
                 (procedure-rename
                  (lambda (user-args ...) (with-bindings ([args user-args] ...) body ... last-body))
                  'name))))]))

(define-syntax-rule (my-if cond then else)
  (syntax-parameterize ([syn-let (...(syntax-rules () [(_ stx ...) (block-let stx ...)]))])
    (Cond-if cond then else)))