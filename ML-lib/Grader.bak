#lang racket
(define languageMap (make-hash))
(hash-set! languageMap "Numbers" '("C1" "C2" "C3"))
(hash-set! languageMap "Conditionals" '("C1" "C2" "C3"))
(hash-set! languageMap "Named Functions" '("C1" "C2" "C3"))
(hash-set! languageMap "Scope" '("C1" "C2" "A1" "A2"))
(hash-set! languageMap "For" '("C1" "C2"))
(hash-set! languageMap "Anonymous Functions" '("C1" "C2"))
(hash-set! languageMap "Mutable Vars" '("C1" "C2" "A1"))
(hash-set! languageMap "Fields" '("C1" "C2" "A1" "P1" "P2"))
(define languageNames
  (foldl (lambda (key str)
           (string-append key "\n" str))
         ""
         (hash-keys languageMap)))

(define args (current-command-line-arguments))
(define languageLevels
  (hash-ref languageMap (vector-ref args 0)
            (lambda () (error (~a "Invalid language. You input \""
                                  (vector-ref args 0) "\". The valid options are:\n"
                                  languageNames)))))

;(define answerArray (cadr args))
;We might just cat a \\ between answers and a \\Classifier between rows of the array. Doesn't matter.

(define-syntax-rule (for id list body ...)
  (map (lambda (id) body ...) list))

(define (makeEquivalenceClasses answerRow)
  (define labeledAnswers
    (map (lambda (answer level) (cons answer level))
         answerRow
         languageLevels))
  (define (helper remaining)
    (cond
      [(null? remaining) null]
      [(cons? remaining)
       (cons (list->set
              (map (lambda (x) (cdr x))
                   (filter (lambda (x) (equal? (car x) (caar remaining)))
                           remaining)))
             (helper
              (filter (lambda (x) (not (equal? (car x) (caar remaining))))
                      remaining)))]))
  (helper labeledAnswers))


(define (combineEquivalenceClasses ecs1 ecs2)
  (filter (lambda (z) (not (set-empty? z)))
          (foldl (lambda (x acc1)
                   (append
                    (foldl (lambda (y acc2) (cons (set-intersect x y) acc2)) '() ecs2)
                    acc1))
                 '()
                 ecs1)))

(define (scoreEquivalenceClasses classes)
  (define listClasses (map set->list classes))
  (define cores (filter cons? (map (lambda (x) (filter (lambda (y) (string-prefix? y "C")) x))
                     listClasses)))
  (define advanced (filter cons? (map (lambda (x) (filter (lambda (y) (not (string-prefix? y "P"))) x))
                     listClasses)))
  (define coreDistinctions (- (length cores) 1))
  (define advancedDistinctions (foldl (lambda (x distinctions) (if (and (= (length x) 1) (string-prefix? (car x) "A"))
                                                                   (+ distinctions 1)
                                                                   distinctions))
                                      0
                                      advanced))
  (define prankDistinctions (foldl (lambda (x distinctions) (if (and (= (length x) 1) (string-prefix? (car x) "P"))
                                                                   (+ distinctions 1)
                                                                   distinctions))
                                      0
                                      listClasses))
  (define possibleCoreDistinctions (- (length (filter (lambda (x) (string-prefix? x "C")) languageLevels)) 1))
  (define possibleAdvancedDistinctions (length (filter (lambda (x) (string-prefix? x "A")) languageLevels)))
  (define possiblePrankDistinctions (length (filter (lambda (x) (string-prefix? x "P")) languageLevels)))
  (define coreString "")
  (define advancedString "")
  (define prankString "")
  (when (> possibleCoreDistinctions 0)
      (set! coreString (~a "Core: " coreDistinctions "/" possibleCoreDistinctions)))
  (when (> possibleAdvancedDistinctions 0)
      (set! advancedString (~a " Advanced: " advancedDistinctions "/" possibleAdvancedDistinctions)))
  (when (> possiblePrankDistinctions 0)
      (set! prankString (~a " Prank: " prankDistinctions "/" possiblePrankDistinctions)))
  (~a coreString advancedString prankString))
