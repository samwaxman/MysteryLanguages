#lang racket
(require (prefix-in Cond- "../Conditionals/Conditionals3.rkt")
         (for-syntax syntax/parse)
         racket/splicing
         "../ML-Helpers.rkt"
         racket/stxparam)
(provide
 (except-out (unprefix-out Cond- "../Conditionals/Conditionals3.rkt")
             Cond-#%top Cond-#%module-begin Cond-#%let Cond-#%block)
 #%block
 #%reassign
 (rename-out [my-let #%let]
             [my-module-begin #%module-begin]
             [my-top #%top]
             [func #%func]))

;;Our environment!
(define env '())

;;Must use a function defined in this file
;;To set the environment. set! is not allowed
;;To appear in the syntax of other files when
;;It's trying to set a module provided identifier
(define (set-env new-env)
  (set! env new-env))

;; Delays the lookup until runtime.
(define-syntax-rule (my-top . var)
  (lookup 'var))

;;Looks up var (must be a literal, not the var itself) in the environment
(define (lookup var)
  (define (lookup-helper var flat-env)
    (cond
      [(null? flat-env) (raise-user-error (~a "Unbound identifier: " var))]
      [(cons? flat-env) (if (eq? (vector-ref (car flat-env) 0)
                                 var)
                            (vector-ref (car flat-env) 1)
                            (lookup-helper var (cdr flat-env)))]))
  (lookup-helper var (flatten env)))

(define (#%reassign-in-scope scope var new-value)
  (cond
    [(null? scope) '()]
    [(cons? scope) (if (eq? (vector-ref (car scope) 0) var)
                       (cons (cons var new-value) (cdr scope))
                       (cons (car scope) (#%reassign-in-scope (cdr scope var new-value))))]))

(define (#%reassign var new-value)
  (define (#%reassign-helper var new-value environment)
    (cond
      [(null? environment) (raise-user-error (~a "Unbound identifier: " var))]
      [(cons? environment)
       (let ([scope
              (#%reassign-in-scope (car environment)
                                   var
                                   new-value)])
         (if scope
             (cons scope (cdr environment))
             (cons (car environment) (#%reassign-helper var new-value (cdr environment)))))]))
  (set-env (#%reassign-helper var new-value env)))

;;Pushes a binding onto the environment
(define-syntax-rule (push id binding)
  (set-env (cons (cons (vector 'id binding) (car env)) (cdr env))))

;;Begins a new scope
(define (begin-scope)
  (set-env (cons null env)))

;;Pops the things we defined in the current scope
;;from the environment
(define (exit-scope)
  (set-env (cdr env)))

;; Adds the bindings to the environment, evaluates the body,
;; and then pops off the bindings
(define-syntax-rule (with-bindings ([var binding] ...) body ...)
  (begin
    (begin-scope)
    (push var binding) ...
    ;;Change the immediate lambdas to let () in these cases
    (let ([result (let () body ...)])
      (exit-scope)
      result)))

;let's are splicing and don't introduce a new scope
(define-syntax-rule (my-let ([id binding]) body ... last-body)
  (let () (push id binding) body ... last-body))
(define-syntax-rule (block-let ([id binding]) body ... last-body)
  (begin (begin-scope) (push id binding) (let ([result (begin body ... last-body)])
                                           (exit-scope) result)))

(define-syntax-rule (my-module-begin body ...)
  (Cond-#%module-begin (set-env '()) (begin-scope) (let ([result (begin body ...)]) (exit-scope) result)))



;;Pushes func binding onto the environment,
;;and pushes the function-argument bindings onto the environment
;;whenever the function is called.
(define-syntax (#%lambda stx)
  (syntax-case stx ()
    [(_ (args ...) body ... last-body)
     (with-syntax ([(user-args ...) (generate-temporaries #'(args ...))])
       #'(push name
               (procedure-rename
                (lambda (user-args ...) (check-decrement-fuel)
                  (with-bindings ([args user-args] ...) body ... last-body))
                (string->symbol "anonymous function"))))]))

(define-syntax-rule (#%block first-body body ...)
  (with-binding () first-body body ...))
