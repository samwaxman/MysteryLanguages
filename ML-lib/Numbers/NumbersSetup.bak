#lang racket
(require racket/splicing)
(require (for-syntax syntax/parse))
(require "../ML-Helpers.rkt")
(provide ML+ ML- ML* ML/  ML-let
         add-setter
         subtract-setter
         multiply-setter
         divide-setter
         #%id
         #%block)

;Defines functions for add subtract multiply and divide
;and defines setters for them
(make-shared-variable add)
(make-shared-variable subtract)
(make-shared-variable multiply)
(make-shared-variable divide)

(define (ML+ num1 num2)
  ;ML-contract is checking the contract on the arguments
  (check-contract '+ (num1 num2) (real? real?) ("number" "number"))
  (add num1 num2))

(define (ML- num1 num2)
  (check-contract '- (num1 num2) (real? real?) ("number" "number"))
  (subtract num1 num2))

(define (ML* num1 num2)
  (check-contract '* (num1 num2) (real? real?) ("number" "number"))
  (multiply num1 num2))

(define (ML/ num1 num2)
  (check-contract '/ (num1 num2) (real? real?) ("number" "number"))
  (divide num1 num2))

(define-syntax (ML-let stx)
  (syntax-parse stx
    [(_ ([name binding]) body ... last-body)
     #'(let ([name binding]) body ... last-body)]))

;Racket doesn't have a wrapper for
;when variables turn into values
;like it does for #%datum and such
;so we made one! Right now, it's the identity
;transform
(define-syntax-rule (#%id id)
  id)

;Handles the block: syntax. Shouldn't need to be
;overriden
(define-syntax-rule (#%block body ...)
  (let () body ...))
