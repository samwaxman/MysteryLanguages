#lang racket
(require (for-syntax syntax/parse))
(require "../ML-Helpers.rkt")
(require (prefix-in MV3- "../MutableVars/MutableVars3.rkt"))
(require "fields-common-base.rkt")
(require "../testPrinter.rkt")
(provide
 record
 reassign-field
 access
 (unprefix-out MV3- "../MutableVars/MutableVars3.rkt")
 (all-from-out "../testPrinter.rkt")
 )





(define-syntax-rule (field-cond field)
  (values #t field))
(define-syntax-rule (field-trans field)
  (string-downcase (~my-a field)))
;value, and return transformer
(define-syntax-rule (iden-trans x)
  x)

;Can't happen - no values are dissallowed (condition is #t)
(define (on-create-bad-field) (void))
(define (on-access-bad-field) (void))

(define-syntax-rule (my-mod body ...)
  (#%module-begin
   (splicing-syntax-parameterize
       ([field-condition (... (syntax-rules () [(_ stx ...) (field-cond stx ...)]))]
        [value-transformer (... (syntax-rules () [(_ stx ...) (iden-trans stx ...)]))]
        [return-transformer (... (syntax-rules () [(_ stx ...) (iden-trans stx ...)]))]
        [field-transformer (... (syntax-rules () [(_ stx ...) (field-trans stx ...)]))])
     (set-create-error on-create-bad-field)
     (set-access-error on-access-bad-field)
     body ...)))