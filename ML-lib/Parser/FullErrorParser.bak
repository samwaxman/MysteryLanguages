#lang racket
(require megaparsack megaparsack/text)
(require data/monad)
(require data/applicative)
(require (for-syntax syntax/parse))
(require syntax/strip-context)
(require "lexer.rkt"
         parser-tools/lex)
(require megaparsack/parser-tools/lex)
(provide ML-parse)

(define (ML-parse src in language
                  #:NumberMode [nm 'exact]
                  #:let ML-let
                  #:if [ML-if #f]
                  #:func [ML-func #f]
                  #:reassign [ML-reassign #f]
                  #:lambda [ML-lambda #f]
                  #:record [ML-record #f]
                  #:+ [ML+ #f]
                  #:- [ML- #f]
                  #:/ [ML/ #f]
                  #:* [ML* #f]
                  #:++ [ML++ #f]
                  #:== [ML== #f]
                  #:!= [ML!= #f]
                  #:> [ML> #f]
                  #:< [ML< #f]
                  #:<= [ML<= #f]
                  #:>= [ML>= #f]
                  #:for [ML-for #f]
                  #:list [ML-list #f])
  
(define (string-to-num str-num transformer)
  (cond
          [(eq? str-num "-Inf") -inf.0]
          [(eq? str-num "Inf") +inf.0]
          [(eq? str-num "NaN") +nan.0]
          [else (transformer str-num)]))
 (define (exactify-num str-num)
   (string-to-num str-num (lambda (x) (string->number (string-append "#e" x)))))
  (define (inexactify-num str-num)
   (string-to-num str-num (lambda (x) (string->number (string-append "#i" x)))))
  (define (racket-num str-num)
   (string-to-num str-num (lambda (x) (string->number x))))
  (define number-transform
    (cond
      [(eq? nm 'exact) exactify-num]
      [(eq? nm 'inexact) inexactify-num]
      [(eq? nm 'racket) racket-num]))


(define (if-def-parse syn parser)
    (do (if syn parser (fail/p (message (srcloc #f #f #f #f #f) #f '())))))
  
(define unacceptable-ids
  (foldl (lambda (x acc) (if (car x) (cons (cdr x) acc) acc))
         '()
         (list (cons ML-lambda 'lam) (cons ML-func 'fun)
               (cons ML-if 'if) (cons ML-if 'true)
               (cons ML-if 'else) (cons ML-for 'list)
               (cons ML-if 'false) (cons ML-for 'for)
               (cons (or ML-if ML-func ML-lambda) 'end)
               (cons ML-for 'in))))

  (define (precedence-level op)
    (or
     (and (eq? op "(") -inf.0)
     (and (member op precedence-ops) 1)
     (and (member op (dict-keys binary-op-builtins)) 0)))
  (define precedence-ops
    (list "*" "/"))

  (define binary-op-builtins
    (foldr (lambda (x acc) (if (cdr x) (cons x acc) acc)) '() (list (cons "++" ML++) (cons "+" ML+) (cons "-" ML-) (cons "/" ML/) (cons "*" ML*)
                                                                    (cons "!=" ML!=) (cons "<=" ML<=) (cons ">=" ML>=) (cons ">" ML>) (cons "<" ML<)
                                                                    (cons "==" ML==))))
  (define identifier/p
   (guard/p (syntax/p  (token/p 'Identifier))
                      (lambda (x) (let ([id (syntax->datum x)])
                                    (nor (member (symbol->string id) binary-op-builtins) (member id unacceptable-ids))))
                        "Identifier"
                        (lambda (x) (syntax->datum x))))
  
  (define number/p
    (do
        [num <- (syntax/p (token/p 'Number))]
      (let* ([str-num (syntax->datum num)]
             [new-num (number-transform str-num)])
        (pure (datum->syntax num new-num num)))))
        

  (define string/p
    (syntax/p (token/p 'String)))

   (define whitespace/p
    (many/p (or/p
             (token/p 'newline)
             (token/p 'space)) #:min 1))
  (define w-i/p
    (many/p whitespace/p #:min 0))
 
  
  (define (double-space-insensitive single/p)
    (do
        (many/p whitespace/p #:min 0)
      [res <- single/p]
      (many/p whitespace/p #:min 0)
      (pure res)))
  (define at-least-one-newline/p
    (or/p
     (do
         (token/p 'space)
       (token/p 'newline))
     (do
         (token/p 'space)
       (token/p 'comment))
     (token/p 'newline)
     (token/p 'comment)))
  (define newline-jump/p
    (do
        (or/p
         (try/p
          (do
              at-least-one-newline/p
            whitespace/p))
         at-least-one-newline/p)))
  
  (define (seq/p single/p)
    (do
        (token/p 'left-paren)
      [seq <- (many/p (syntax/p single/p) #:sep (double-space-insensitive (token/p 'comma)) #:min 0)]
      (token/p 'right-paren)
      (syntax/p (pure seq))))
  
  (define function/p
    (do
        [fun <- (guard/p (syntax/p (token/p 'Identifier))
                         (lambda (id) (eq? (syntax->datum id) 'fun))
                         "fun"
                         (lambda (x) (syntax->datum x)))]
      (token/p 'space)
      [name  <- identifier/p]
      [sequence <- (seq/p identifier/p)]
      (double-space-insensitive (token/p 'colon))
      w-i/p
      [block <- (block/p (keyword/p 'end))]
      (let ([annotated-func (datum->syntax ML-func (syntax->datum ML-func) fun)])
      (syntax/p (pure (append (list annotated-func name sequence) (syntax->list block)))))))

  (define boolean/p
    (guard/p (syntax/p (token/p 'Identifier))
             (lambda (x) (member (syntax->datum x) (list 'true 'false)))
             "Boolean"
             (lambda (x) (syntax->datum x))))

  (define (keyword/p symbol)
    (guard/p (syntax/p (token/p 'Identifier))
             (lambda (x) (eq? symbol (syntax->datum x)))
             (symbol->string symbol)
             (lambda (x) (syntax->datum x))))
  
  (define (reassign/p)
    (do
        [id <- identifier/p]
      w-i/p
      [:= <- (syntax/p (token/p 'reassign))]
      w-i/p
      [new-val <- (argument/p)]
      (let ([decorated-reassign
             (datum->syntax ML-reassign
                            (syntax->datum ML-reassign)
                            :=)])
        (syntax/p (pure (list decorated-reassign id new-val))))))

(define (lambda/p)
    (do
        [lam <- (keyword/p 'lam)]
      [args <- (seq/p identifier/p)]
      w-i/p
      (token/p 'colon)
      w-i/p
      [bodies <- (block/p (keyword/p 'end))]
      (let ([decorated-lam
             (datum->syntax ML-lambda
                            (syntax->datum ML-lambda)
                            lam)])
      (syntax/p (pure (cons (list decorated-lam args) bodies))))))
  (define list/p
    (do
        (token/p 'left-bracket)
      [syn-list <- (keyword/p 'list)]
      (token/p 'colon)
      w-i/p
      [els <- (many/p (argument/p) #:min 0 #:sep (double-space-insensitive (token/p 'comma)))]
      (token/p 'right-bracket)
      (let ([decorated-list (datum->syntax ML-list
                                           (syntax->datum ML-list)
                                           syn-list)])
      (syntax/p (pure (cons decorated-list els))))))

  ;fix messages
  (define for/p
    (do
        [syn-for <- (keyword/p 'for)]
      whitespace/p
      [id <- identifier/p]
      whitespace/p
      (keyword/p 'in)
      whitespace/p
      [in-list <- list/p]
      w-i/p
      (token/p 'colon)
      w-i/p
      [bodies <- (block/p (keyword/p 'end))]
      (let ([decorated-for (datum->syntax ML-for
                                          (syntax->datum ML-for)
                                          syn-for)])                   
      (syntax/p (pure (append (list decorated-for id in-list) bodies))))))
      
  (define if/p
    (do
        [syn-if <- (keyword/p 'if)]
      w-i/p
      [cond <- (argument/p)]
      w-i/p
      (token/p 'colon)
      w-i/p
      [then <- (block/p (keyword/p 'else) #f #t)]
      w-i/p
      (token/p 'colon)
      w-i/p
      [else <- (block/p (keyword/p 'end) #f #t)]
      (let ([decorated-if (datum->syntax ML-if
                                         (syntax->datum ML-if)
                                         syn-if)])
      (syntax/p (pure (list decorated-if cond (cons #'begin then) (cons #'begin else)))))))
  
  (define primitive/p
    (or/p
     (if-def-parse ML-for list/p)
     ;do a try/p for and then after getting it, go in
     (try/p (if-def-parse ML-for (label/p "for" for/p)))
     (try/p (if-def-parse ML-reassign (reassign/p)))
     (try/p (if-def-parse ML-if (label/p "if" if/p)))
     number/p
     (try/p identifier/p)
     string/p
     (try/p (if-def-parse ML-if  (label/p "Boolean" boolean/p)))
     (if-def-parse ML-lambda (label/p "lam" (lambda/p)))))

  ;might be bad messsages here
  (define (argument/p)
    (binary-op/p
     (or/p
      (try/p app/p)
      primitive/p)))

  (define app/p
    (do
        [prim <- primitive/p]
      [apps <- (many/p (seq/p (argument/p)) #:min 1)]
      (syntax/p (pure (foldl (lambda (x acc) (cons acc x)) prim apps)))))

  (define operator/p
    (do
        whitespace/p
      (or/p
       (do [op <- (guard/p (token/p 'Operator)
                           (lambda (x) (member x (dict-keys binary-op-builtins)))
                           "Operator"
                           (lambda (x) x))]
         whitespace/p
         (pure op))
       (do
           [op <- (guard/p (syntax/p (token/p 'Identifier))
                           (lambda (x) (member (symbol->string (syntax->datum x)) (dict-keys binary-op-builtins)))
                           "Operator"
                           (lambda (x) (syntax->datum x)))]
         whitespace/p
         (pure (symbol->string (syntax->datum op)))))))

  ;;THIS WILL GET REVAMPED SOON!!
   (define (to-prefix-notation postfix-list)
    (define (helper h-list)
      (if (member (car h-list) (dict-keys binary-op-builtins))
          (let-values ([(first f-processed) (helper (cdr h-list))])
            (let-values ([(second s-processed) (helper (drop h-list (+ f-processed 1)))])
              (values (reverse (list first second (dict-ref binary-op-builtins (car h-list)))) (+ 1 f-processed s-processed))))
          (values (car h-list) 1)))
    ;it's never null but this is needed so that the monads don't go crazy on ya
    (if (null? postfix-list) ""
        (let-values ([(prefix _) (helper postfix-list)])
          prefix)))
  (define (move-operations op op-list output)
    (if (or (null? op-list)
            (> (precedence-level op)
               (precedence-level (car op-list))))
        (values (cons op op-list) output)
        (move-operations op (cdr op-list) (cons (car op-list) output))))
  (define (right-paren ops out)
    (cond
      [(null? ops) (values #f #f)]
      [(eq? (car ops) "(") (values ops out)]
      [else (right-paren (cdr ops) (cons (car ops) out))]))
  (define (binary-op/p single [start-expr (list)] [start-op (list)])
    (do
        [binary <- (guard/p (postfix-list/p single start-expr start-op)
                            (lambda (x) (and
                                         (car x)
                                         (cons? (cdr x))
                                         (not (member "(" (cdr x)))
                                         (or
                                          (member (car (cdr x)) (dict-keys binary-op-builtins))
                                          (= (length (cdr x)) 1)))))]
      (let ([final (to-prefix-notation (cdr binary))])
        (pure final))))
  
  (define (postfix-list/p single-parse [start-expr (list)] [start-op (list)])
    (define (helper output operations last-expr?)
      (or/p
       ;if you encounter right paren, let the helper take care of it and continue
       (try/p (if last-expr? (do
                  w-i/p
                (token/p 'right-paren)
                (let-values ([(op-list out) (right-paren operations output)])
                  (if (and op-list out)
                      (or/p
                       ;this might mess up error reporting for this one case
                       (try/p (do
                           [op <- (label/p "operator" operator/p)]
                         (let-values ([(op-list* out*) (move-operations op (cdr op-list) out)])
                           (try/p (helper out* op-list* #f)))))
                       (helper out (cdr op-list) #t))
                      (fail/p (message (srcloc #f #f #f #f #f) ")" '())))))
              (fail/p (message (srcloc #f #f #f #f #f) #f '()))))
       ;Otherwise, parse an expr
       (do
                  [expr1 <- (syntax/p single-parse)]
                (or/p
                 ;see if there's another op after it.
                 ;if so, move-operations and continue
                 (try/p (do
                            [opr1 <- (label/p "operator" operator/p)]
                          (let-values ([(op-list out) (move-operations opr1 operations (cons expr1 output))])
                            (helper  out op-list #f))))
                 ;otherwise, there might be a right-paren so check that with the helper
                 (helper (cons expr1 output) operations #t)))
       ;if no expressions were found, see if there's a left-paren
       (try/p (do
                  w-i/p
                (token/p 'left-paren)
                (helper output (cons "(" operations) #f)))
       ;if not we're done.
       (pure (cons last-expr? (append (reverse operations) output)))))
    (helper start-expr start-op #f))

  ;END BINARY
  (define blockable/p
    (or/p
     number/p
     identifier/p
     boolean/p))

  
      
  (define (let/p end/p top-level? if?)
    (do
        [id <- identifier/p]
      w-i/p
      [= <- (syntax/p (token/p '=))]
      w-i/p
      [binding <- (argument/p)]
      w-i/p
      [rest <- (block/p end/p top-level? if?)]
      (let ([decorated-let (datum->syntax ML-let
                                          (syntax->datum ML-let)
                                          =)])
        (syntax/p (pure (list (append (list decorated-let (list (list id binding))) (syntax->list rest))))))))

  ;fix messages for let by taking out the id into a separate case
  (define (block/p end/p [top-level? #f] [if? #f])
    (or/p
     (do
         (token/p 'comment)
       w-i/p
       (block/p end/p top-level? if?))
     (try/p (let/p end/p top-level? if?))
     (do
          [first <- (argument/p)]
       (or/p
        ;error messages
        (try/p (do
                   w-i/p
            end/p
          (syntax/p (pure (list first)))))
        (do
            newline-jump/p
            [rest <- (block/p end/p top-level? if?)]
          (syntax/p (pure (cons first rest))))))
     (if-def-parse (not if?) (do
         [fun <- function/p]
       (or/p
        (if-def-parse
         top-level? (try/p
                     (do w-i/p
                       end/p
                       (syntax/p (pure (list fun))))))
         (do
         newline-jump/p
           [rest <- (block/p end/p top-level? if?)]
           (syntax/p (pure (cons fun rest)))))))))
 
  (define (top-level-block/p)
    (or/p
     (try/p (do
         w-i/p
              (many/p (token/p 'comment) #:min 0)
         (token/p 'end-of-file)
       (syntax/p (pure (list)))))
     (do
         w-i/p
     (block/p (token/p 'end-of-file) #t))))

  ;make a decorate function that you set down here which will allw you to decorate everything that you provide from the other alnguage

  (let ([lexed (lex in (string-length (string-append "#lang  " (symbol->string language))))])
    (with-syntax ([(code ...) (parse-result! (parse-tokens (top-level-block/p) lexed (object-name in)))]
                  [language language])
      #`(module MysteryLang #,(strip-context #'language) code ...)
      )))